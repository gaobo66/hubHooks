import{_ as s,c as a,a4 as n,o as l}from"./chunks/framework.BDeXF6e8.js";const c=JSON.parse('{"title":"核心功能","description":"","frontmatter":{},"headers":[],"relativePath":"front/build-tools/webpack/index.md","filePath":"front/build-tools/webpack/index.md","lastUpdated":1736751316000}'),e={name:"front/build-tools/webpack/index.md"};function t(p,i,h,r,k,o){return l(),a("div",null,i[0]||(i[0]=[n(`<h1 id="核心功能" tabindex="-1">核心功能 <a class="header-anchor" href="#核心功能" aria-label="Permalink to &quot;核心功能&quot;">​</a></h1><p>webpack 的作用是将源代码编译（构建、打包）成最终代码。</p><p><a href="https://gitee.com/dev-edu/frontend-webpack-particular/raw/master/1.%20webpack%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/1-8.%20%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B/assets/2020-01-09-10-26-15.png" target="_blank" rel="noreferrer">webpack编译</a></p><p>整个过程大致分为三个步骤</p><ol><li><p>初始化</p><p>此阶段，webpack会将<strong>CLI参数</strong>、<strong>配置文件</strong>、<strong>默认配置</strong>进行融合，形成一个最终的配置对象。</p></li><li><p>编译</p><ul><li><p><strong>创建chunk</strong></p><p>每个chunk都有至少两个属性：</p><ul><li>name：默认为main</li><li>id：唯一编号，开发环境和name相同，生产环境是一个数字，从0开始</li></ul></li><li><p><strong>构建所有依赖模块</strong></p></li><li><p><strong>产生chunk assets</strong></p></li><li><p><strong>合并chunk assets</strong></p></li></ul></li><li><p>输出</p><p>webpack将利用node中的fs模块（文件处理模块），根据编译产生的总的assets，生成相应的文件。</p><p><img src="https://gitee.com/gbsy/imgs/raw/master/typora-img/202501131017136.png" alt="img"></p></li></ol><p><strong>涉及术语</strong></p><ol><li>module：模块，分割的代码单元，webpack中的模块可以是任何内容的文件，不仅限于JS</li><li>chunk：webpack内部构建模块的块，一个chunk中包含多个模块，这些模块是从入口模块通过依赖分析得来的</li><li>bundle：chunk构建好模块后会生成chunk的资源清单，清单中的每一项就是一个bundle，可以认为bundle就是最终生成的文件</li><li>hash：最终的资源清单所有内容联合生成的hash值</li><li>chunkhash：chunk生成的资源清单内容联合生成的hash值</li><li>chunkname：chunk的名称，如果没有配置则使用main</li><li>id：通常指chunk的唯一编号，如果在开发环境下构建，和chunkname相同；如果是生产环境下构建，则使用一个从0开始的数字进行编号</li></ol><h1 id="css工程化" tabindex="-1">CSS工程化 <a class="header-anchor" href="#css工程化" aria-label="Permalink to &quot;CSS工程化&quot;">​</a></h1><h1 id="js兼容性" tabindex="-1">JS兼容性 <a class="header-anchor" href="#js兼容性" aria-label="Permalink to &quot;JS兼容性&quot;">​</a></h1><h1 id="性能优化" tabindex="-1">性能优化 <a class="header-anchor" href="#性能优化" aria-label="Permalink to &quot;性能优化&quot;">​</a></h1><p>性能优化主要体现在三个方面：</p><ol><li><p><strong>构建性能</strong></p><p>这里所说的构建性能，是指在<strong>开发阶段的构建性能</strong>，而不是生产环境的构建性能。</p><p>优化的目标，<strong>是降低从打包开始，到代码效果呈现所经过的时间</strong></p><p>构建性能会影响开发效率。构建性能越高，开发过程中时间的浪费越少</p></li><li><p><strong>传输性能</strong></p><p>传输性能是指，打包后的JS代码传输到浏览器经过的时间</p><p>在优化传输性能时要考虑到：</p><ol><li>总传输量：所有需要传输的JS文件的内容加起来，就是总传输量，重复代码越少，总传输量越少</li><li>文件数量：当访问页面时，需要传输的JS文件数量，文件数量越多，http请求越多，响应速度越慢</li><li>浏览器缓存：JS文件会被浏览器缓存，被缓存的文件不会再进行传输</li></ol></li><li><p><strong>运行性能</strong></p></li></ol><p>​ 运行性能是指，JS代码在浏览器端的运行速度。它主要取决于我们如何书写高性能的代码。</p><p>代码分析插件：webpack-bundle-analyzer</p><h2 id="热替换" tabindex="-1">热替换 <a class="header-anchor" href="#热替换" aria-label="Permalink to &quot;热替换&quot;">​</a></h2><p>热替换并不能降低构建时间（可能还会稍微增加），但可以降低代码改动到效果呈现的时间。 HotModuleReplacementPlugin插件可以实现热替换功能</p><h2 id="懒加载" tabindex="-1">懒加载 <a class="header-anchor" href="#懒加载" aria-label="Permalink to &quot;懒加载&quot;">​</a></h2><h2 id="代码压缩" tabindex="-1">代码压缩 <a class="header-anchor" href="#代码压缩" aria-label="Permalink to &quot;代码压缩&quot;">​</a></h2><p>目前最流行的代码压缩工具主要有两个：UglifyJs和<a href="https://terser.org/" target="_blank" rel="noreferrer">Terser</a></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> TerserPlugin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;terser-webpack-plugin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> OptimizeCSSAssetsPlugin</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;optimize-css-assets-webpack-plugin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  optimization: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 是否要启用压缩，默认情况下，生产环境会自动开启</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    minimize: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    minimizer: [ </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 压缩时使用的插件，可以有多个</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> TerserPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> OptimizeCSSAssetsPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h2 id="分包" tabindex="-1">分包 <a class="header-anchor" href="#分包" aria-label="Permalink to &quot;分包&quot;">​</a></h2><h3 id="手动分包" tabindex="-1">手动分包 <a class="header-anchor" href="#手动分包" aria-label="Permalink to &quot;手动分包&quot;">​</a></h3><h3 id="自动分包" tabindex="-1">自动分包 <a class="header-anchor" href="#自动分包" aria-label="Permalink to &quot;自动分包&quot;">​</a></h3><p><code>webpack在内部是使用SplitChunksPlugin进行分包的 过去有一个库CommonsChunkPlugin也可以实现分包 不过由于该库某些地方并不完善，到了webpack4之后，已被SplitChunksPlugin取代</code></p><ol><li>检查每个chunk编译的结果</li><li>根据分包策略，找到那些满足策略的模块</li><li>根据分包策略，生成新的chunk打包这些模块（代码有所变化）</li><li>把打包出去的模块从原始包中移除，并修正原始包代码</li></ol><h3 id="其他" tabindex="-1">其他 <a class="header-anchor" href="#其他" aria-label="Permalink to &quot;其他&quot;">​</a></h3><h3 id="gzip" tabindex="-1">gzip <a class="header-anchor" href="#gzip" aria-label="Permalink to &quot;gzip&quot;">​</a></h3><p>gzip是一种B/S结构中的压缩文件的传输算法。</p><blockquote><p>优点：传输效率可能得到大幅提升 缺点：服务器的压缩需要时间，客户端的解压需要时间</p></blockquote><p>使用compression-webpack-plugin插件对打包结果进行预压缩，可以移除服务器的压缩时间</p><h3 id="减少模块解析" tabindex="-1">减少模块解析 <a class="header-anchor" href="#减少模块解析" aria-label="Permalink to &quot;减少模块解析&quot;">​</a></h3><p>如果没有loader对该模块进行处理，该模块的源码就是最终打包结果的代码。 如果不对某个模块进行解析，可以缩短构建时间，些已经打包好的第三方库，比如jquery</p>`,32)]))}const g=s(e,[["render",t]]);export{c as __pageData,g as default};
