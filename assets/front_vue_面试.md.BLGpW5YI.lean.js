import{_ as t,c as i,a4 as o,o as r}from"./chunks/framework.BDeXF6e8.js";const d=JSON.parse('{"title":"面试","description":"","frontmatter":{},"headers":[],"relativePath":"front/vue/面试.md","filePath":"front/vue/面试.md","lastUpdated":1733733351000}'),s={name:"front/vue/面试.md"};function e(n,l,p,a,g,c){return r(),i("div",null,l[0]||(l[0]=[o('<h1 id="面试" tabindex="-1">面试 <a class="header-anchor" href="#面试" aria-label="Permalink to &quot;面试&quot;">​</a></h1><h2 id="面试题-一次性给你-10000-条数据-前端怎么渲染到页面上" tabindex="-1">面试题：一次性给你 10000 条数据，前端怎么渲染到页面上？ <a class="header-anchor" href="#面试题-一次性给你-10000-条数据-前端怎么渲染到页面上" aria-label="Permalink to &quot;面试题：一次性给你 10000 条数据，前端怎么渲染到页面上？&quot;">​</a></h2><p>长列表常见的 3 种处理方式：</p><ol><li>懒加载</li><li>时间分片</li><li>虚拟列表</li></ol><p><strong>懒加载</strong></p><p>懒加载的原理在于：只有视口内的内容会被加载，其他内容在用户滚动到视口时才会被加载。这可以显著减少初次加载的时间，提高页面响应速度。这样的好处在于：</p><ol><li>节省带宽</li><li>提升用户体验</li></ol><p>懒加载的缺点：懒加载只能应对数据不是太多的情况。如果列表项有几万甚至几十万项，最终会有对应数量的 DOM 存在于页面上，严重降低页面性能。</p><p><strong>时间分片</strong></p><p>时间分片的本质是通过 requestAnimationFrame，<strong>由浏览器来决定回调函数的执行时机</strong>。大量的数据会被分多次渲染，每次渲染对应一个片段。在每个片段中处理定量的数据后，会将主线程还给浏览器，从而实现快速呈现页面内容给用户。</p><p>时间分片的缺点：</p><ol><li>效率低</li><li>不直观</li><li>性能差</li></ol><p>总结：无论是懒加载还是时间分片，最终都是将完整数量的列表项渲染出来，这在面对列表项非常非常多的时候，页面性能是比较低的。</p><p><strong>虚拟列表</strong></p><p>原理：设置一个可视区域，然后用户在滚动列表的时候，本质上是<strong>动态修改可视区域里面的内容</strong>。</p><p>实现思路：</p><ol><li><p>实现定高的虚拟列表，指的定高是说列表项的每一项高度相同</p><p>涉及到的信息：</p><ul><li>可视区域起始数据索引(startIndex)</li><li>可视区域结束数据索引(endIndex)</li><li>可视区域的数据</li><li>整个列表中的偏移位置 startOffset</li></ul><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2024-07-01-084455.png" alt="image-20240701164454859" style="zoom:50%;"></li><li><p>优化点</p><ul><li>动态高度</li><li>白屏现象</li><li>滚动事件触发频率过高</li></ul><ol><li><p>动态高度</p><p>不固定的高度就会导致：</p><ul><li>列表总高度：listHeight = listData.length * itemSize</li><li>偏移量的计算：startOffset = scrollTop - (scrollTop % itemSize)</li><li>数据的起始索引 startIndex = Math.floor(scrollTop / itemSize)</li></ul><p>这些属性的计算不能再通过上面的方式来计算。因此我们会遇到这样的一些问题：</p><ul><li>如何获取真实高度？ <ul><li>如果能获得列表项高度数组，真实高度问题就很好解决。但在实际渲染之前是<strong>很难拿到每一项的真实高度</strong>的，所以我们采用<strong>预估一个高度</strong>渲染出真实 DOM，再根据 DOM 的实际情况去更新真实高度。</li><li>创建一个<strong>缓存列表</strong>，其中列表项字段为 索引、高度与定位，并<strong>预估列表项高度</strong>用于<strong>初始化缓存列表</strong>。在渲染后根据 DOM 实际情况<strong>更新缓存列表</strong>。</li></ul></li><li>相关属性该如何计算？ <ul><li>显然以前的计算方式都无法使用了，因为那都是针对固定值设计的。</li><li>于是我们需要 <strong>根据缓存列表重写计算属性、滚动回调函数</strong>，例如列表总高度的计算可以使用缓存列表最后一项的定位字段的值。</li></ul></li><li>列表渲染的项目有何改变？ <ul><li>因为用于渲染页面元素的数据是根据 <strong>开始/结束索引</strong> 在 <strong>数据列表</strong> 中筛选出来的，所以只要保证索引的正确计算，那么<strong>渲染方式是无需变化</strong>的。</li><li>对于开始索引，我们将原先的计算公式改为：在 <strong>缓存列表</strong> 中搜索第一个底部定位大于 <strong>列表垂直偏移量</strong> 的项并返回它的索引</li><li>对于结束索引，它是根据开始索引生成的，无需修改。</li></ul></li></ul></li><li><p>白屏问题</p><p>仅渲染可视区域的元素。此时如果用户滚动过快，会出现白屏闪烁的现象。</p><p>之所以会有这个现象，是因为先加载出来的是白屏（没有渲染内容），然后迅速会被替换为表格内容，从而出现闪烁的现象。</p><p>并且这种现象在越低性能的浏览器上面表现得越明显。</p><p><em><strong>解决思路：</strong></em></p><p>为了让页面的滚动更加平滑，我们可以在原先列表结构的基础上加上<strong>缓冲区</strong>，也就是整个渲染区域由 <strong>可视区 + 缓冲区</strong> 共同组成，这样就给滚动回调和页面渲染留出了更多的时间。</p></li><li><p>滚动事件触发频率过高</p></li></ol></li></ol><p>​ 绑定的是 scroll 滚动事件，虽然效果实现了，但是 scroll 事件的触发频率非常高，每次用户一滚动就会触发，而每次触发都会执行 scroll 回调方法。</p><p><em><strong>解决思路：</strong></em></p><p>可以使用 IntersectionObserver 来替换监听 scroll 事件。</p><p>相比 scroll，IntersectionObserver 可以设置多个阈值来检测元素进入视口的不同程度，只在必要时才进行计算，没有性能上的浪费。并且监听回调也是异步触发的。</p><h3 id="完整代码" tabindex="-1">完整代码 <a class="header-anchor" href="#完整代码" aria-label="Permalink to &quot;完整代码&quot;">​</a></h3><p><a href="./实践.html">虚拟列表code</a></p>',23)]))}const m=t(s,[["render",e]]);export{d as __pageData,m as default};
