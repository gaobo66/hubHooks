import{_ as i,c as a,a4 as n,o as l}from"./chunks/framework.BDeXF6e8.js";const o=JSON.parse('{"title":"面试","description":"","frontmatter":{},"headers":[],"relativePath":"front/vue/面试.md","filePath":"front/vue/面试.md","lastUpdated":1733903940000}'),t={name:"front/vue/面试.md"};function h(p,s,k,e,r,g){return l(),a("div",null,s[0]||(s[0]=[n(`<h1 id="面试" tabindex="-1">面试 <a class="header-anchor" href="#面试" aria-label="Permalink to &quot;面试&quot;">​</a></h1><h2 id="面试题-一次性给你-10000-条数据-前端怎么渲染到页面上" tabindex="-1">面试题：一次性给你 10000 条数据，前端怎么渲染到页面上？ <a class="header-anchor" href="#面试题-一次性给你-10000-条数据-前端怎么渲染到页面上" aria-label="Permalink to &quot;面试题：一次性给你 10000 条数据，前端怎么渲染到页面上？&quot;">​</a></h2><p>长列表常见的 3 种处理方式：</p><ol><li>懒加载</li><li>时间分片</li><li>虚拟列表</li></ol><p><strong>懒加载</strong></p><p>懒加载的原理在于：只有视口内的内容会被加载，其他内容在用户滚动到视口时才会被加载。这可以显著减少初次加载的时间，提高页面响应速度。这样的好处在于：</p><ol><li>节省带宽</li><li>提升用户体验</li></ol><p>懒加载的缺点：懒加载只能应对数据不是太多的情况。如果列表项有几万甚至几十万项，最终会有对应数量的 DOM 存在于页面上，严重降低页面性能。</p><p><strong>时间分片</strong></p><p>时间分片的本质是通过 requestAnimationFrame，<strong>由浏览器来决定回调函数的执行时机</strong>。大量的数据会被分多次渲染，每次渲染对应一个片段。在每个片段中处理定量的数据后，会将主线程还给浏览器，从而实现快速呈现页面内容给用户。</p><p>时间分片的缺点：</p><ol><li>效率低</li><li>不直观</li><li>性能差</li></ol><p>总结：无论是懒加载还是时间分片，最终都是将完整数量的列表项渲染出来，这在面对列表项非常非常多的时候，页面性能是比较低的。</p><p><strong>虚拟列表</strong></p><p>原理：设置一个可视区域，然后用户在滚动列表的时候，本质上是<strong>动态修改可视区域里面的内容</strong>。</p><p>实现思路：</p><ol><li><p>实现定高的虚拟列表，指的定高是说列表项的每一项高度相同</p><p>涉及到的信息：</p><ul><li>可视区域起始数据索引(startIndex)</li><li>可视区域结束数据索引(endIndex)</li><li>可视区域的数据</li><li>整个列表中的偏移位置 startOffset</li></ul><img src="https://xiejie-typora.oss-cn-chengdu.aliyuncs.com/2024-07-01-084455.png" alt="image-20240701164454859" style="zoom:50%;"></li><li><p>优化点</p><ul><li>动态高度</li><li>白屏现象</li><li>滚动事件触发频率过高</li></ul><ol><li><p>动态高度</p><p>不固定的高度就会导致：</p><ul><li>列表总高度：listHeight = listData.length * itemSize</li><li>偏移量的计算：startOffset = scrollTop - (scrollTop % itemSize)</li><li>数据的起始索引 startIndex = Math.floor(scrollTop / itemSize)</li></ul><p>这些属性的计算不能再通过上面的方式来计算。因此我们会遇到这样的一些问题：</p><ul><li>如何获取真实高度？ <ul><li>如果能获得列表项高度数组，真实高度问题就很好解决。但在实际渲染之前是<strong>很难拿到每一项的真实高度</strong>的，所以我们采用<strong>预估一个高度</strong>渲染出真实 DOM，再根据 DOM 的实际情况去更新真实高度。</li><li>创建一个<strong>缓存列表</strong>，其中列表项字段为 索引、高度与定位，并<strong>预估列表项高度</strong>用于<strong>初始化缓存列表</strong>。在渲染后根据 DOM 实际情况<strong>更新缓存列表</strong>。</li></ul></li><li>相关属性该如何计算？ <ul><li>显然以前的计算方式都无法使用了，因为那都是针对固定值设计的。</li><li>于是我们需要 <strong>根据缓存列表重写计算属性、滚动回调函数</strong>，例如列表总高度的计算可以使用缓存列表最后一项的定位字段的值。</li></ul></li><li>列表渲染的项目有何改变？ <ul><li>因为用于渲染页面元素的数据是根据 <strong>开始/结束索引</strong> 在 <strong>数据列表</strong> 中筛选出来的，所以只要保证索引的正确计算，那么<strong>渲染方式是无需变化</strong>的。</li><li>对于开始索引，我们将原先的计算公式改为：在 <strong>缓存列表</strong> 中搜索第一个底部定位大于 <strong>列表垂直偏移量</strong> 的项并返回它的索引</li><li>对于结束索引，它是根据开始索引生成的，无需修改。</li></ul></li></ul></li><li><p>白屏问题</p><p>仅渲染可视区域的元素。此时如果用户滚动过快，会出现白屏闪烁的现象。</p><p>之所以会有这个现象，是因为先加载出来的是白屏（没有渲染内容），然后迅速会被替换为表格内容，从而出现闪烁的现象。</p><p>并且这种现象在越低性能的浏览器上面表现得越明显。</p><p><em><strong>解决思路：</strong></em></p><p>为了让页面的滚动更加平滑，我们可以在原先列表结构的基础上加上<strong>缓冲区</strong>，也就是整个渲染区域由 <strong>可视区 + 缓冲区</strong> 共同组成，这样就给滚动回调和页面渲染留出了更多的时间。</p></li><li><p>滚动事件触发频率过高</p></li></ol></li></ol><p>​ 绑定的是 scroll 滚动事件，虽然效果实现了，但是 scroll 事件的触发频率非常高，每次用户一滚动就会触发，而每次触发都会执行 scroll 回调方法。</p><p><em><strong>解决思路：</strong></em></p><p>可以使用 IntersectionObserver 来替换监听 scroll 事件。</p><p>相比 scroll，IntersectionObserver 可以设置多个阈值来检测元素进入视口的不同程度，只在必要时才进行计算，没有性能上的浪费。并且监听回调也是异步触发的。</p><h3 id="完整代码" tabindex="-1">完整代码 <a class="header-anchor" href="#完整代码" aria-label="Permalink to &quot;完整代码&quot;">​</a></h3><p><a href="./实践.html#pro_virtualList">虚拟列表code</a></p><h2 id="面试题-vue-的-nexttick-是如何实现的" tabindex="-1">面试题：Vue 的 nextTick 是如何实现的？ <a class="header-anchor" href="#面试题-vue-的-nexttick-是如何实现的" aria-label="Permalink to &quot;面试题：Vue 的 nextTick 是如何实现的？&quot;">​</a></h2><p>参考答案：</p><p>nextTick 的本质将回调函数包装为一个微任务放入到微任务队列，这样浏览器在完成渲染任务后会优先执行微任务。</p><p>nextTick 在 Vue2 和 Vue3 里的实现有一些不同：</p><ol><li>Vue2 为了兼容旧浏览器，会根据不同的环境选择不同包装策略：</li></ol><ul><li>优先使用 Promise，因为它是现代浏览器中最有效的微任务实现。</li><li>如果不支持 Promise，则使用 MutationObserver，这是另一种微任务机制。</li><li>在 IE 环境下，使用 setImmediate，这是一种表现接近微任务的宏任务。</li><li>最后是 setTimeout(fn, 0) 作为兜底方案，这是一个宏任务，但会在下一个事件循环中尽快执行。</li></ul><ol><li>Vue3 则是只考虑现代浏览器环境，直接使用 Promise 来实现微任务的包装，这样做的好处在于代码更加简洁，性能更高，因为不需要处理多种环境的兼容性问题。</li></ol><p>整体来讲，Vue3 的 nextTick 实现更加简洁和高效，是基于现代浏览器环境的优化版本，而 Vue2 则为了兼容性考虑，实现层面存在更多的兼容性代码。</p><p><a href="https://github.com/vuejs/core/blob/main/packages/runtime-core/src/scheduler.ts#L56" target="_blank" rel="noreferrer">nextTick源码</a></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 创建一个已经解析的 Promise 对象，这个 Promise 会立即被解决，</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 用于创建一个微任务（microtask）。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> resolvedPromise</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> /*#__PURE__*/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">resolve</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">as</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">any</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 一个全局变量，用于跟踪当前的刷新 Promise。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 初始状态为 null，表示当前没有刷新任务。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentFlushPromise</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">|</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// queueFlush 函数负责将刷新任务（flushJobs）放入微任务队列。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 这是 Vue 的异步更新机制的核心部分，用于优化性能。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> queueFlush</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 检查是否已经在刷新（isFlushing）或者刷新任务是否已被挂起（isFlushPending）。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">isFlushing </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">isFlushPending) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 设置 isFlushPending 为 true，表示刷新任务已被挂起，正在等待执行。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    isFlushPending </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 将 currentFlushPromise 设置为 resolvedPromise.then(flushJobs)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 这将创建一个微任务，当 resolvedPromise 被解决时，执行 flushJobs 函数。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    currentFlushPromise </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> resolvedPromise.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flushJobs)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// nextTick 函数用于在下一个 DOM 更新循环之后执行一个回调函数。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 它返回一个 Promise，这个 Promise 会在 DOM 更新完成后解决。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> nextTick</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">T</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">R</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> void</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;(</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> T</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> R</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,  </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 可选的回调函数，在 DOM 更新之后执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Awaited</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">R</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&gt; {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果 currentFlushPromise 不为 null，使用它；否则使用 resolvedPromise。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 这样可以确保在 DOM 更新之后再执行回调。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> currentFlushPromise </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> resolvedPromise</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果传入了回调函数 fn，返回一个新的 Promise，在 p 解决之后执行 fn。</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 使用 this 绑定来确保回调函数的上下文正确。</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fn </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fn.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">bind</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fn) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> p</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果没有传入回调函数 fn，直接返回 Promise p，这样外部代码可以使用 await 等待 DOM 更新完成。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,33)]))}const E=i(t,[["render",h]]);export{o as __pageData,E as default};
